# 宏任务和微任务

异步任务的两种

![img](宏任务和微任务.assets/1053223-20180831162152579-2034514663.png)

![img](宏任务和微任务.assets/1053223-20180831162350437-143973108.png)

例子：

```javascript
//同步任务
console.log(1);
//宏任务
setTimeout(()=>{
    console.log(2);
},0);
//微任务
Promise.resolve(3).then(b=>{
    console.log(b);
});

//  1 3 2
```

## 宏任务（macrotask queue）

| #                     | 浏览器 | Node |
| --------------------- | ------ | ---- |
| setTimeout            | √      | √    |
| setInterval           | √      | √    |
| setImmediate          | x      | √    |
| requestAnimationFrame | √      | x    |

## 微任务（microtask queue）

| #                          | 浏览器 | Node |
| -------------------------- | ------ | ---- |
| process.nextTick           | x      | √    |
| MutationObserver           | √      | x    |
| Promise.then catch finally | √      | √    |
| Object.observe             | √      | √    |

## 例子

```javascript
//主线程直接执行
console.log('1');
//丢到宏事件队列中
setTimeout(function() {
    console.log('2');
    /**
    node.js下执行的
    process.nextTick(function() {
        console.log('3');
    }) 
    **/
    new Promise(function(resolve) {
        console.log('4');
        resolve();
    }).then(function() {
        console.log('5')
    })
})
//微事件1
/**
node.js下执行的
process.nextTick(function() {
    console.log('6');
})
**/
//主线程直接执行
new Promise(function(resolve) {
    console.log('7');
    resolve();
}).then(function() {
    //微事件2
    console.log('8')
})
//丢到宏事件队列中
setTimeout(function() {
    console.log('9');
    /**
    node.js下执行的
    process.nextTick(function() {
        console.log('10');
    })
    **/
    new Promise(function(resolve) {
        console.log('11');
        resolve();
    }).then(function() {
        console.log('12')
    })
})
```

首先浏览器执行js进入第一个宏任务进入主线程, 直接打印console.log('1')

- 遇到 **setTimeout**  分发到宏任务Event Queue中
- 遇到 process.nextTick 丢到微任务Event Queue中
- 遇到 Promise， new Promise 直接执行 输出 console.log('7');
- 执行then 被分发到微任务Event Queue中``
- 第一轮宏任务执行结束，开始执行微任务 打印 6,8
- 第一轮微任务执行完毕，执行第二轮宏事件，执行setTimeout
- 先执行主线程宏任务，在执行微任务，打印'2,4,3,5'
- 在执行第二个setTimeout,同理打印 ‘9,11,10,12’
- 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。



执行机制：

1. 执行全局Script同步代码，这些同步代码有一些是同步语句，有一些是异步语句（比如setTimeout等）；
2. 全局Script代码执行完毕后，调用栈Stack会清空；
3. 从微队列microtask queue中取出位于队首的回调任务，放入调用栈Stack中执行，执行完后microtask queue长度减1；
4. 继续取出位于队首的任务，放入调用栈Stack中执行，以此类推，直到直到把microtask queue中的所有任务都执行完毕。注意，如果在执行microtask的过程中，又产生了microtask，那么会加入到队列的末尾，也会在这个周期被调用执行；
5. microtask queue中的所有任务都执行完毕，此时microtask queue为空队列，调用栈Stack也为空；
6. 取出宏队列macrotask queue中位于队首的任务，放入Stack中执行；执行过程中如果产生了microtask则重复2-4步骤；
7. 执行完毕后，调用栈Stack为空；
8. 重复第3-7个步骤；
9. 重复第3-7个步骤