# Obejct对象

## `Object`的原生方法

分为两类：

1. `Object`本身的方法
2. `Object`的实例方法

### `Obejct`本身的方法

即直接定义在`Object`对象的方法

```javascript
Object.print = function (o) { console.log(o) };
```

> 此处`print`方法为直接定义在`Object`对象上

### `Object`的实例方法

即定义在`Object`原型对象`Object.prototype`上的方法，可直接被`Object`的实例使用

```javascript
Object.prototype.print = function () {
  console.log(this);
};

var obj = new Object();
obj.print() // Object
```

## `Object()`

用于将任意值转为对象，常用于保证某个值一定是对象

> 若参数为空或undefined或null，Object()返回一个空对象

```javascript
var obj = Object();
// 等同于
var obj = Object(undefined);
var obj = Object(null);

obj instanceof Object // true
```

若参数是原始类型的值，`Object()`将其转为对应的包装对象的实例：

```javascript
var obj = Object(1);
obj instanceof Object // true
obj instanceof Number // true

var obj = Object('foo');
obj instanceof Object // true
obj instanceof String // true

var obj = Object(true);
obj instanceof Object // true
obj instanceof Boolean // true
```

若参数时一个对象，则总是返回该对象，没有转换：

```javascript
var arr = [];
var obj = Object(arr); // 返回原数组
obj === arr // true

var value = {};
var obj = Object(value) // 返回原对象
obj === value // true

var fn = function () {};
var obj = Object(fn); // 返回原函数
obj === fn // true
```

可用于判断变量是否为对象：

```javascript
function isObject(value) {
  return value === Object(value);
}

isObject([]) // true
isObject(true) // false
```

## Object构造函数

直接用于生成新对象：

```javascript
var obj = new Object();
//等价于
var obj = {};
```

用法与`Object()`类似

```javascript
var o1 = {a: 1};
var o2 = new Object(o1);
o1 === o2 // true

var obj = new Object(123);
obj instanceof Number // true
```

但

+ `Object(value)`语义为将`value`转为一个对象
+ `new Object(value)`语义为新生成一个对象，其值为`value`

## Object静态方法

即指部署在`Object`对象自身的方法

### `Object.keys()`，`Object.getOwnPropertyNames()`

都用于遍历对象的属性

`Object.keys()`的参数时一个对象，返回一个数组。

数组内的成员为对象自身的所有属性名。（非继承而来的）

```javascript
var obj = {
  p1: 123,
  p2: 456
};

Object.keys(obj) // ["p1", "p2"]
```

一般而言两个方法返回结果一样。

但若涉及不可枚举属性时，`Object.keys()`只返回可枚举的属性，而另一个可返回不可枚举的属性

```javascript
var a = ['Hello', 'World'];

Object.keys(a) // ["0", "1"]
Object.getOwnPropertyNames(a) // ["0", "1", "length"]
```

以上，数组的`length`属性为不可枚举的属性。

可用于计算对象属性的数量：

```javascript
var obj = {
  p1: 123,
  p2: 456
};

Object.keys(obj).length // 2
Object.getOwnPropertyNames(obj).length // 2
```

### 其他方法

**（1）对象属性模型的相关方法**

- `Object.getOwnPropertyDescriptor()`：获取某个属性的描述对象。
- `Object.defineProperty()`：通过描述对象，定义某个属性。
- `Object.defineProperties()`：通过描述对象，定义多个属性。

**（2）控制对象状态的方法**

- `Object.preventExtensions()`：防止对象扩展。
- `Object.isExtensible()`：判断对象是否可扩展。
- `Object.seal()`：禁止对象配置。
- `Object.isSealed()`：判断一个对象是否可配置。
- `Object.freeze()`：冻结一个对象。
- `Object.isFrozen()`：判断一个对象是否被冻结。

**（3）原型链相关方法**

- `Object.create()`：该方法可以指定原型对象和属性，返回一个新的对象。
- `Object.getPrototypeOf()`：获取对象的`Prototype`对象。

## Object的实例方法

定义在`Object.prototype`对象上的方法，称为实例方法：

- `Object.prototype.valueOf()`：返回当前对象对应的值。
- `Object.prototype.toString()`：返回当前对象对应的字符串形式。
- `Object.prototype.toLocaleString()`：返回当前对象对应的本地字符串形式。
- `Object.prototype.hasOwnProperty()`：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。
- `Object.prototype.isPrototypeOf()`：判断当前对象是否为另一个对象的原型。
- `Object.prototype.propertyIsEnumerable()`：判断某个属性是否可枚举。

### `Object.prototype.valueOf()`

返回一个对象的值，默认返回对象本身

```javascript
var obj = new Object();
obj.valueOf() === obj // true
```

在进行自动类型转换时会默认调用这个方法

可自定义

### `Object.prototype.toString()`

返回一个对象的字符串形式，默认返回类型字符串

```javascript
var o1 = new Object();
o1.toString() // "[object Object]"

var o2 = {a:1};
o2.toString() // "[object Object]"
```

> 第二个Object表示该值的构造函数

数组、字符串、函数、Date对象分别有自定义的`toString()`方法：

```javascript
[1, 2, 3].toString() // "1,2,3"

'123'.toString() // "123"

(function () {
  return 123;
}).toString()
// "function () {
//   return 123;
// }"

(new Date()).toString()
// "Tue May 10 2016 09:11:31 GMT+0800 (CST)"
```

#### `toString()`应用：判断数据类型

由于实例对象可能会自定义`toString()`方法，因而为了获得类型字符串，应该：

```javascript
Object.prototype.toString.call(value);
```

不同数据类型的返回值：

- 数值：返回`[object Number]`。
- 字符串：返回`[object String]`。
- 布尔值：返回`[object Boolean]`。
- undefined：返回`[object Undefined]`。
- null：返回`[object Null]`。
- 数组：返回`[object Array]`。
- arguments 对象：返回`[object Arguments]`。
- 函数：返回`[object Function]`。
- Error 对象：返回`[object Error]`。
- Date 对象：返回`[object Date]`。
- RegExp 对象：返回`[object RegExp]`。
- 其他对象：返回`[object Object]`。

类型判断函数：

```javascript
var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};

type({}); // "object"
type([]); // "array"
type(5); // "number"
type(null); // "null"
type(); // "undefined"
type(/abcd/); // "regex"
type(new Date()); // "date"
```

专门用于判断某种类型数据的方法：

```javascript
var type = function (o){
  var s = Object.prototype.toString.call(o);
  return s.match(/\[object (.*?)\]/)[1].toLowerCase();
};

['Null',
 'Undefined',
 'Object',
 'Array',
 'String',
 'Number',
 'Boolean',
 'Function',
 'RegExp'
].forEach(function (t) {
  type['is' + t] = function (o) {
    return type(o) === t.toLowerCase();
  };
});

type.isObject({}) // true
type.isNumber(NaN) // true
type.isRegExp(/abc/) // true
```

### `Object.prototype.toLocaleString()`

与`toString()`返回结果相同，返回一个值的字符串形式

```javascript
var obj = {};
obj.toString(obj) // "[object Object]"
obj.toLocaleString(obj) // "[object Object]"
```

可用于留一个借口返回针对不同地域的值

目前有三个对象自定义了`toLocaleString()`方法：

+ Array.prototype.toLocaleString()
+ Number.prototype.toLocaleString()
+ Date.prototype.toLocaleString()

```javascript
var date = new Date();
date.toString() // "Tue Jan 01 2018 12:01:33 GMT+0800 (CST)"
date.toLocaleString() // "1/01/2018, 12:01:33 PM"
```

### `Object.prototype.hasOwnProperty()`

接收一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性

```javascript
var obj = {
  p: 123
};

obj.hasOwnProperty('p') // true
obj.hasOwnProperty('toString') // false
```

> 继承的属性会返回false



# 属性描述对象

JavaScript有一个内部数据结构，用于描述对象的属性，控制其行为，如：

```javascript
{
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false,
  get: undefined,
  set: undefined
}
```

##　6个元属性：

1. `value`

为该属性的属性值，默认为`undefined`

2. `writable`

布尔值，表示属性值是否可改变，默认为`true`

3. `enumerable`

布尔值，表示属性值是否可遍历，默认为`true`，若设为`false`，会使如`for...in`循环、`Object.keys()`操作跳过该属性

4. `configurable`

布尔值，表示可配置性，控制属性描述对象的可写性，默认为`true`，若设为`false`，将阻止某些操作改写，如无法删除或无法改变该属性的属性描述对象（`value`除外）。

5. `get`

函数，表示该属性的取值函数（getter），默认为`undefined`

6. `set`

函数，表示该属性的存值函数（setter），默认为`undefined`

## `Object.getOwnPropertyDescriptor()`

获取属性描述对象

第一个参数为目标对象，第二个参数为字符串，对应目标对象的某个属性名

==*==不能用于继承的属性

```javascript
var obj = { p: 'a' };

Object.getOwnPropertyDescriptor(obj, 'p')
// Object { value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```

## `Object.getOwnPropertyNames()`

返回一个数组，成员为参数对象自身的全部属性的属性名，不管是否可遍历

```javascript
var obj = Object.defineProperties({}, {
  p1: { value: 1, enumerable: true },
  p2: { value: 2, enumerable: false }
});

Object.getOwnPropertyNames(obj)
// ["p1", "p2"]
```

## `Object.defineProperty()`、`Object.defineProperties()`

通过属性描述对象，定义或修改一个属性，然后返回修改后的对象：

```javascript
Object.defineProperty(object,propertyName,attributesObject);
```

+ object：属性所在的对象
+ propertyName：字符串，表示属性名
+ attributesObject：属性描述对象

例如：

```javascript
var obj = Object.defineProperty({}, 'p', {
  value: 123,
  writable: false,
  enumerable: true,
  configurable: false
});

obj.p // 123

obj.p = 246;  //writable为false
obj.p // 123
```

```javascript
var obj = Object.defineProperties({}, {
  p1: { value: 123, enumerable: true },
  p2: { value: 'abc', enumerable: true },
  p3: { get: function () { return this.p1 + this.p2 },
    enumerable:true,
    configurable:true
  }
});

obj.p1 // 123
obj.p2 // "abc"
obj.p3 // "123abc"
```

> 一旦定义了取值函数`get`或存值函数`set`，就不能将`writable`属性设为`true`，或同时定义`value`属性
>
> ```javascript
> var obj = {};
> 
> Object.defineProperty(obj, 'p', {
>   value: 123,
>   get: function() { return 456; }
> });
> // TypeError: Invalid property.
> // A property cannot both have accessors and be writable or have a value
> 
> Object.defineProperty(obj, 'p', {
>   writable: true,
>   get: function() { return 456; }
> });
> // TypeError: Invalid property descriptor.
> // Cannot both specify accessors and a value or writable attribute
> ```

==**==两个方法设置参数里面的属性描述对象，`writable`、`configurable`、`enumerable`这三个属性的默认值都为`false`

## `Object.prototype.propertyIsEnumerable()`

返回一个布尔值，用于判断某个属性是否可遍历

只用于判断对象自身的属性，对于继承的属性均返回`false`

```javascript
var obj = {};
obj.p = 123;

obj.propertyIsEnumerable('p') // true
obj.propertyIsEnumerable('toString') // false
```

## 元属性

### `value`

目标属性值

```javascript
var obj = {};
obj.p = 123;

Object.getOwnPropertyDescriptor(obj, 'p').value
// 123

Object.defineProperty(obj, 'p', { value: 246 });
obj.p // 246
```

### `writable`

布尔值，决定目标属性值是否可以被改变

```javascript
var obj = {};

Object.defineProperty(obj, 'a', {
  value: 37,
  writable: false
});

obj.a // 37
obj.a = 25;
obj.a // 37
```

正常模式下，若`writable:false`下对属性进行赋值，不会报错，但没有效果

严格模式下，会报错

```javascript
'use strict';
var obj = {};

Object.defineProperty(obj, 'a', {
  value: 37,
  writable: false
});

obj.a = 37;
// Uncaught TypeError: Cannot assign to read only property 'a' of object
```

若原型对象的某个属性为`writable:false`，那么子对象也无法自定义这个属性

```javascript
var proto = Object.defineProperty({}, 'foo', {
  value: 'a',
  writable: false
});

var obj = Object.create(proto);

obj.foo = 'b';
obj.foo // 'a'
```

但这种情况可以通过覆盖属性描述对象来避开这个限制：

```javascript
Object.defineProperty(obj, 'foo', {
  value: 'b'
});

obj.foo // "b"
```

### `enumerable`

返回布尔值，表示目标属性是否可遍历

若一个属性为`enumerable:false`，那么三个操作不会取到该属性：

1. `for...in`循环（包括继承属性）
2. `Object.keys`方法（不包括继承属性）
3. `JSON.stringify`方法（用于若对象的JSON格式输出需要排除某些属性）

### `configurable`

返回布尔值，决定是否可以修改属性描述对象

决定目标属性是否可以被删除

> 但`writable`由`true`改为`false`是允许的

> 且`value`，只要`writable`与`configurable`有一个为`true`，就可以改动

```javascript
var o1 = Object.defineProperty({}, 'p', {
  value: 1,
  writable: true,
  configurable: false
});

Object.defineProperty(o1, 'p', {value: 2})
// 修改成功

var o2 = Object.defineProperty({}, 'p', {
  value: 1,
  writable: false,
  configurable: true
});

Object.defineProperty(o2, 'p', {value: 2})
// 修改成功
```

## 存取器

存值函数：`setter`，使用属性描述对象的`set`属性，只能接收一个参数，即属性的值

取值函数：`getter`，使用属性描述对象的`get`属性，不能接受参数

对目标属性定义了存取器，那么在存取的时候都会执行对应的函数

```javascript
var obj = Object.defineProperty({}, 'p', {
  get: function () {
    return 'getter';
  },
  set: function (value) {
    console.log('setter: ' + value);
  }
});

obj.p // "getter"
obj.p = 123 // "setter: 123"
```

另一种写法：更泛用

```javascript
var obj = {
  get p() {
    return 'getter';
  },
  set p(value) {
    console.log('setter: ' + value);
  }
};
```

往往用于属性的值需要依赖对象内部数据的场合：

```javascript
var obj ={
  $n : 5,
  get next() { return this.$n++ },
  set next(n) {
    if (n >= this.$n) this.$n = n;
    else throw new Error('新的值必须大于当前值');
  }
};

obj.next // 5

obj.next = 10;
obj.next // 10

obj.next = 5;
// Uncaught Error: 新的值必须大于当前值
```

## 对象的拷贝

将一个对象的属性拷贝到另一个对象：

```javascript
var extend = function (to, from) {
  for (var property in from) {
    to[property] = from[property];
  }

  return to;
}

extend({}, {
  a: 1
})
// {a: 1}
```

但若遇到存取器定义的属性，只会拷贝值：

```javascript
extend({}, {
  get a() { return 1 }
})
// {a: 1}
```

为了解决这个问题，可以通过`Object.defineProperty`方法来拷贝属性。

```javascript
var extend = function (to, from) {
  for (var property in from) {
    if (!from.hasOwnProperty(property)) continue;  //过滤继承的属性
    Object.defineProperty(
      to,
      property,
      Object.getOwnPropertyDescriptor(from, property)
    );
  }

  return to;
}

extend({}, { get a(){ return 1 } })
// { get a(){ return 1 } })
```

上面代码中，`hasOwnProperty`那一行用来过滤掉继承的属性，否则可能会报错，因为`Object.getOwnPropertyDescriptor`读不到继承属性的属性描述对象。

## 控制对象状态

三种冻结对象方法：

1. `Object.preventExtensions`，最弱
2. `Object.sesal`，其次
3. `Object.freeze`，最强

### `Object.preventExtensions`

可以使对象无法再添加新的属性

```javascript
var obj = new Object();
Object.preventExtensions(obj);

Object.defineProperty(obj, 'p', {
  value: 'hello'
});
// TypeError: Cannot define property:p, object is not extensible.

obj.p = 1;
obj.p // undefined
```

### `Object.isExtensible()`

用于检查一个对象是否使用了`Object.preventExtensions`方法

即检查对象是否可添加属性

```javascript
var obj = new Object();

Object.isExtensible(obj) // true
Object.preventExtensions(obj);
Object.isExtensible(obj) // false
```

### `Object.seal`

使一个对象既无法添加新属性，也无法删除旧属性

但不影响修改某个属性的值，因为`writable`属性不变，因此可以修改`value`

实质是将对象属性的`configurable`设为`false`

```javascript
var obj = { p: 'hello' };
Object.seal(obj);

delete obj.p;
obj.p // "hello"

obj.x = 'world';
obj.x // undefined
```

修改`configurable`

```javascript
var obj = {
  p: 'a'
};

// seal方法之前
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: true
// }

Object.seal(obj);

// seal方法之后
Object.getOwnPropertyDescriptor(obj, 'p')
// Object {
//   value: "a",
//   writable: true,
//   enumerable: true,
//   configurable: false
// }

Object.defineProperty(o, 'p', {
  enumerable: false
})
// TypeError: Cannot redefine property: p
```

### `Object.isSealed()`

用于检查一个对象是否使用了`Object.seal()`方法

```javascript
var obj = { p: 'a' };

Object.seal(obj);
Object.isSealed(obj) // true
//因为无法添加属性，因而isExtensible()也返回false
Object.isExtensible(obj) // false
```

### `Object.freeze()`

可以使一个对象无法添加新属性、无法删除就属性，也无法改变属性的值，使对象变为常量

```javascript
var obj = {
  p: 'hello'
};

Object.freeze(obj);

obj.p = 'world';
obj.p // "hello"

obj.t = 'hello';
obj.t // undefined

delete obj.p // false
obj.p // "hello"
```

在严格模式下报错，在普通模式下失败

### `Object.isFrozen()`

用于检查对象是否使用了`Object.freeze()`方法

可用于确认某个对象没有冻结后，再对其属性进行赋值

```javascript
var obj = {
  p: 'hello'
};

Object.freeze(obj);
Object.isFrozen(obj) // true
Object.isSealed(obj); // true
Object.isExtensible(obj); // false
```

## 局限性

三种冻结方法有几个漏洞

1. 可以通过改变原型对象从而为对象增加属性：

```javascript
var obj = new Object();
Object.preventExtensions(obj);

var proto = Object.getPrototypeOf(obj);
proto.t = 'hello';
obj.t
//hello
```

解决方案：将`obj`的原型也冰冻住

```javascript
var obj = new Object();
Object.preventExtensions(obj);

var proto = Object.getPrototypeOf(obj);
Object.preventExtensions(proto);

proto.t = 'hello';
obj.t // undefined
```

2. 若属性值是对象，则只能冻结属性指向的对象，而不能冻结对象本身的内容

```javascript
var obj = {
  foo: 1,
  bar: ['a', 'b']
};
Object.freeze(obj);

obj.bar.push('c');
obj.bar // ["a", "b", "c"]
```

对象被冻结后，无法改变指向，但指向的数组可变

# Array对象

## 构造函数

`Array`作为JavaScript的原生对象，同时也是一个构造函数，可用于生成新数组

有没使用`new`，运行结果一样

```javascript
var arr = new Array(2);
// 等同于
var arr = Array(2);
```

不同的参数行为会不一样：

```javascript
// 无参数时，返回一个空数组
new Array() // []

// 单个正整数参数，表示返回的新数组的长度
new Array(1) // [ empty ]
new Array(2) // [ empty x 2 ]

// 非正整数的数值作为参数，会报错
new Array(3.2) // RangeError: Invalid array length
new Array(-3) // RangeError: Invalid array length

// 单个非数值（比如字符串、布尔值、对象等）作为参数，
// 则该参数是返回的新数组的成员
new Array('abc') // ['abc']
new Array([1]) // [Array[1]]

// 多参数时，所有参数都是返回的新数组的成员
new Array(1, 2) // [1, 2]
new Array('a', 'b', 'c') // ['a', 'b', 'c']
```

> 若参数为正整数，数组成员都为空位
>
> 读取时返回`undefined`，但该位置上没有值
>
> 可以取得`length`属性，但取不到键名
>
> ```javascript
> var a = new Array(3);
> var b = [undefined, undefined, undefined];
> 
> a.length // 3
> b.length // 3
> 
> a[0] // undefined
> b[0] // undefined
> 
> 0 in a // false
> 0 in b // true
> ```

## 静态方法

### `Array.isArray()`

返回一个布尔值，表示参数是否为数组

可以弥补`typeof`运算符的不足

```javascript
var arr = [1, 2, 3];

typeof arr // "object"
Array.isArray(arr) // true
```

## 实例方法

### `valueOf()`、`toString()`

两者都是对象所拥有的方法

数组的`valueOf()`返回数组本身

数组`toString()`返回数组的字符串形式

### `push()`、`pop()`

`push()`在数组末端添加一个或多个元素，并返回添加新元素后的数组长度

> 会改变原数组

```javascript
var arr = [];

arr.push(1) // 1
arr.push('a') // 2
arr.push(true, {}) // 4
arr // [1, 'a', true, {}]
```

`pop()`用于删除数组的最后一个元素，并返回该元素

> 同样会改变原数组

```javascript
var arr = ['a', 'b', 'c'];

arr.pop() // 'c'
arr // ['a', 'b']

//对空数组使用返回undefined
[].pop() // undefined
```

`push()`和`pop()`结合使用，构成“后进先出”的栈结构（stack）

### `shift()`、`unshift()`

`shift()`用于删除数组的第一个元素，并返回该元素

> 会改变原数组

```javascript
var a = ['a', 'b', 'c'];

a.shift() // 'a'
a // ['b', 'c']
```

可以遍历并清空一个数组：

```javascript
var list = [1, 2, 3, 4];
var item;

while (item = list.shift()) {
  console.log(item);
}

list // []
```

`push()`和`shift()`结合使用，构成“先进先出”的队列结构（stack）



`unshift`用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度

> 会改变原数组

```javascript
var a = ['a', 'b', 'c'];

a.unshift('x'); // 4
a // ['x', 'a', 'b', 'c']

//可接收多个参数
var arr = [ 'c', 'd' ];
arr.unshift('a', 'b') // 4
arr // [ 'a', 'b', 'c', 'd' ]
```

### `join()`

以指定参数作为分隔符，将所有数组成员连接为一个字符串返回

若不提供参数，默认使用逗号

```javascript
var a = [1, 2, 3, 4];

a.join(' ') // '1 2 3 4'
a.join(' | ') // "1 | 2 | 3 | 4"
a.join() // "1,2,3,4"
```

若数组成员为`undefined`或`null`，会转化成空字符

```javascript
[undefined, null].join('#')
// '#'

['a',, 'b'].join('-')
// 'a--b'
```

==*==使用`call`方法，可以用于字符串或类似数组的对象：

```javascript
Array.prototype.join.call('hello', '-')
// "h-e-l-l-o"

var obj = { 0: 'a', 1: 'b', length: 2 };
Array.prototype.join.call(obj, '-')
// 'a-b'
```

### `concat()`

用于多个数组的合并

将新数组的成员添加到原数组成员的后部，然后返回一个新数组

> 原数组不变

```javascript
['hello'].concat(['world'])
// ["hello", "world"]

['hello'].concat(['world'], ['!'])
// ["hello", "world", "!"]

[].concat({a: 1}, {b: 2})
// [{ a: 1 }, { b: 2 }]

[2].concat({a: 1})
// [2, {a: 1}]
```

除数组外，还接收其他类型的值作为参数：

```javascript
[1, 2, 3].concat(4, 5, 6)
// [1, 2, 3, 4, 5, 6]
```

若数组成员包括了对象，`concat`方法返回当前数组的一个浅拷贝

即新数组拷贝的是对象的引用

```javascript
var obj = { a: 1 };
var oldArray = [obj];

var newArray = oldArray.concat();

obj.a = 2;
newArray[0].a // 2
```

### `reverse()`

用于颠倒排列数组元素，返回改变后的数组

> 改变原数组

```javascript
var a = ['a', 'b', 'c'];

a.reverse() // ["c", "b", "a"]
a // ["c", "b", "a"]
```

### `slice()`

用于提取目标数组的一部分，返回一个新数组

> 原数组不变

```javascript
arr.slice(start, end);
```

`start`为起始位置（从0开始），`end`为终止位置（但不包括该位置元素，可忽略，忽略则返回到原数组的最后一个成员）

```javascript
var a = ['a', 'b', 'c'];

a.slice(0) // ["a", "b", "c"]
a.slice(1) // ["b", "c"]
a.slice(1, 2) // ["b"]
a.slice(2, 6) // ["c"]
a.slice() // ["a", "b", "c"]
```

若负数则倒数计算位置

若`start`参数大于数组长度，或`end`<`start`，则返回空数组

==**==重要应用：将类似数组的对象转为真正的数组

```javascript
Array.prototype.slice.call({ 0: 'a', 1: 'b', length: 2 })
// ['a', 'b']

Array.prototype.slice.call(document.querySelectorAll("div"));
Array.prototype.slice.call(arguments);
```

### `splice()`

用于删除原数组的一部分成员，并可以在删除的位置添加新的成员，返回被删除的元素

> 会改变原数组

```javascript
arr.splice(start,count,addElement1,addElement2,...);
```

`start`为删除的起始位置（从0开始），`count`为被删除的元素个数，`addElement`为添加的新元素

```javascript
var a = ['a', 'b', 'c', 'd', 'e', 'f'];
a.splice(4, 2, 1, 2) // ["e", "f"]
a // ["a", "b", "c", "d", 1, 2]
```

单纯为了插入元素，`count`设为`0`

若只提供`start`，则将原数组在指定位置拆分成两个数组

### `sort()`

对数组成员进行排序，默认按照字典顺序排序（不是按照大小排序）·

> 原数组被改变

```javascript
['d', 'c', 'b', 'a'].sort()
// ['a', 'b', 'c', 'd']

[4, 3, 2, 1].sort()
// [1, 2, 3, 4]

[11, 101].sort()
// [101, 11]

[10111, 1101, 111].sort()
// [10111, 1101, 111]
```

想按照自定义方式排序，则可以传入一个函数作为参数：

```javascript
[10111, 1101, 111].sort(function (a, b) {
  return a - b;
})
// [111, 1101, 10111]
```

`sort`的函数本身接受两个参数，表示进行比较的两个数组成员

若函数返回值大于`0`，表示第一个成员排在第二个成员后面，其他情况下第一个成员排在第二个成员前面

==*==自定义的排序函数应该返回数值，不推荐返回布尔值

### `map()`

将数组的所有成员依次传入参数函数，然后将每一次执行结果组成一个新数组返回

```javascript
var numbers = [1, 2, 3];

numbers.map(function (n) {
  return n + 1;
});
// [2, 3, 4]

numbers
// [1, 2, 3]
```

`map()`方法接收一个函数作为第一个参数

该函数有三个参数：`elem`当前成员值，`index`当前成员位置，`arr`原数组

```javascript
[1, 2, 3].map(function(elem, index, arr) {
  return elem * index;
});
// [0, 2, 6]
```

`map()`方法第二个参数用于绑定回调函数内部的`this`变量：

```javascript
var arr = ['a', 'b', 'c'];

[1, 2].map(function (e) {
  return this[e];
}, arr)
// ['b', 'c']
```

若数组有空位，`map()`方法的回调函数不会在这个位置执行，会跳过

```javascript
var f = function (n) { return 'a' };

[1, undefined, 2].map(f) // ["a", "a", "a"]
[1, null, 2].map(f) // ["a", "a", "a"]
[1, , 2].map(f) // ["a", , "a"]
```

> 不会跳过`undefined`和`null`，但会跳过空位

### `forEach()`

与`map()`类似，但不返回值，只操作数据

用法与`map()`一致

```javascript
function log(element, index, array) {
  console.log('[' + index + '] = ' + element);
}

[2, 5, 9].forEach(log);
// [0] = 2
// [1] = 5
// [2] = 9
```

接收第二个参数：

```javascript
var out = [];

[1, 2, 3].forEach(function(elem) {
  this.push(elem * elem);
}, out);

out // [1, 4, 9]
```

基本就和`map()`一致

### `filter()`

用于过滤数组成员，满足条件的成员组成一个新数组返回

参数是一个函数，所有数组成员会依次执行该函数，返回结果为`true`的成员组成一个新数组返回

> 不会改变原数组

```javascript
[1, 2, 3, 4, 5].filter(function (elem) {
  return (elem > 3);
})
// [4, 5]

var arr = [0, 1, 'a', false];
arr.filter(Boolean)  // [1, "a"]
```

参数函数可以接收三个参数：`elem`当前成员值，`index`当前成员位置，`arr`原数组

```javascript
[1, 2, 3, 4, 5].filter(function (elem, index, arr) {
  return index % 2 === 0;
});
// [1, 3, 5]
```

接收第二个参数，用来绑定参数函数内部的`this`变量

```javascript
var obj = { MAX: 3 };
var myFilter = function (item) {
  if (item > this.MAX) return true;
};

var arr = [2, 8, 3, 4, 1, 3, 2, 9];
arr.filter(myFilter, obj) // [8, 4, 9]
```

### `some()`、`every()`

类似`assert`，返回一个布尔值，表示判断数组成员是否符合某种条件

接收一个函数作为参数，同上

`some()`方法，只要一个成员的返回值为`true`，则返回`true`，否则返回`false`

```javascript
var arr = [1, 2, 3, 4, 5];
arr.some(function (elem, index, arr) {
  return elem >= 3;
});
// true
```

`every`方法，所有成员的返回值为`true`才返回`true`，否则返回`false`

```javascript
var arr = [1, 2, 3, 4, 5];
arr.every(function (elem, index, arr) {
  return elem >= 3;
});
// false
```

均可绑定第二个参数绑定`this`变量

==*==对于空数组

`some()`返回`false`

`every()`返回`true`

回调函数都不会执行

```javascript
function isEven(x) { return x % 2 === 0 }

[].some(isEven) // false
[].every(isEven) // true
```

### `reduce()`、`reduceRight()`

依次处理数组的每个成员，最终累计为一个值

`reduce()`从第一个成员到最后一个，`reduceRight()`则相反

```javascript
[1, 2, 3, 4, 5].reduce(function (a, b) {
  console.log(a, b);
  return a + b;
})
// 1 2
// 3 3
// 6 4
// 10 5
//最后结果：15
```

第一个参数都是函数，接收四个参数：

1. 累计变量，默认为数组的第一个成员
2. 当前变量，默认为数组的第二个成员
3. 当前位置（从0开始）
4. 原数组

前两者必须，后两个可选

第二个参数，用于对累积变量指定初值：

（此时`b`对应数组的第一个成员）

```javascript
[1, 2, 3, 4, 5].reduce(function (a, b) {
  return a + b;
}, 10);
// 25
```

1. 可用于处理空数组：

 ```javascript
 function add(prev, cur) {
   return prev + cur;
 }
 
 [].reduce(add)
 // TypeError: Reduce of empty array with no initial value
 [].reduce(add, 1)
 // 1
 ```

 空数组没有初始值会报错

2. 还可用于找出字符长度最长的数组成员：

```javascript
function findLongest(entries) {
  return entries.reduce(function (longest, entry) {
    return entry.length > longest.length ? entry : longest;
  }, '');
}

findLongest(['aaa', 'bb', 'c']) // "aaa"
```

### `indexOf()`、`lastIndexOf()`

`indexOf()`返回元素在数组中第一次出现的位置，没有出现返回`-1`

```javascript
var a = ['a', 'b', 'c'];

a.indexOf('b') // 1
a.indexOf('y') // -1
```

接收的第二个参数表示搜索的开始位置

```javascript
['a', 'b', 'c'].indexOf('a', 1) // -1
```

`lastIndexOf()`返回元素在数组中最后一次出现的位置，没有出现返回`-1`



这两个方法都不可以用于搜索`NaN`的位置

```javascript
[NaN].indexOf(NaN) // -1
[NaN].lastIndexOf(NaN) // -1
```

> 因为两个方法内部都是使用`===`进行比较，而`NaN !== NaN`

### 链式使用

数组方法若返回的是数组，则可以链式使用：

```javascript
var users = [
  {name: 'tom', email: 'tom@example.com'},
  {name: 'peter', email: 'peter@example.com'}
];

users
.map(function (user) {
  return user.email;
})    // [tom@example.com,peter@example.com]
.filter(function (email) {
  return /^t/.test(email);
})   // 过滤以t开头的eamil地址
.forEach(function (email) {
  console.log(email);
});   //打印地址
// "tom@example.com"
```

# 包装对象

数据类型中三种原始类型：

+ 数值
+ 字符串
+ 布尔值

三者在一定条件下转化为对象，即为原始类型的‘包装对象’

```javascript
var n = new Number(123); // 123,生成了新的包装类型
var b = new Boolean(true); // true,生成了新的包装类型
var s = new String('str'); // 'str',生成了新的包装类型

typeof n // "object"
typeof b // "object"
typeof s // "object"

n === 123 // false
s === 'abc' // false
b === true // false
```

若不写`new`，则`Number()`、`Boolean`、`String()`会被当作普通函数，正常转换：

```javascript
var n = Number('123'); // 123，相当于parseInt()或parseFloat()
typeof n; // 'number'

var b = Boolean('true'); // true
typeof b; // 'boolean'

var b2 = Boolean('false'); // true! 'false'字符串转换结果为true！因为它是非空字符串！
var b3 = Boolean(''); // false

var s = String(123.45); // '123.45'
typeof s; // 'string'
```

## 共有实例方法

三种包装对象有两种共有的从`Object`对象继承的方法

### `valueOf()`

返回包装对象实例对应的原始类型的值：

```javascript
new Number(123).valueOf()  // 123
new String('abc').valueOf() // "abc"
new Boolean(true).valueOf() // true
```

### `toString`

返回对应的字符串形式

```javascript
new Number(123).toString() // "123"
new String('abc').toString() // "abc"
new Boolean(true).toString() // "true"
```

## 原始类型与实例对象的自动转换

某些场景，原始类型的值会自动当作包装对象调用

此时，JavaScript引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例



字符串可以调用`length`属性：

```javascript
'abc'.length //3
```

等同于：

```javascript
var str = 'abc';
str.length // 3

// 等同于
var strObj = new String(str)
// String {
//   0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"
// }
strObj.length // 3
```

自动转换的包装对象是只读的，无法修改

因而无法添加新属性：

```javascript
var s = 'Hello World';
s.x = 123;
s.x // undefined
```

每次调用都会生成新的包装对象实例，调用结束之后都会销毁

## 自定义方法

在对象的原型上自定义方法，便可以在所有实例对象上调用：

```javascript
String.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

'abc'.double()
// abcabc

Number.prototype.double = function () {
  return this.valueOf() + this.valueOf();
};

(123).double() // 246
```

# Boolean对象

用于生成布尔值的包装对象实例

```javascript
var b = new Boolean(true);

typeof b; // 'object'
b.valueOf(); // true
```

==*==`false`对应的包装对象实例，布尔运算结果也是`true`：

```javascript
if (new Boolean(false)) {   //false对应的包装对象实例是一个对象，对象对应的布尔值为true
  console.log('true');
} // true

if (new Boolean(false).valueOf()) {
  console.log('true');
} // 无输出
```

## 类型转换作用

```javascript
Boolean(undefined) // false
Boolean(null) // false
Boolean(0) // false
Boolean('') // false
Boolean(NaN) // false

Boolean(1) // true
Boolean('false') // true
Boolean([]) // true
Boolean({}) // true
Boolean(function () {}) // true
Boolean(/foo/) // true
```

使用双重否运算符也可以将任意值转为对应的布尔值：

```javascript
!!undefined // false
!!null // false
!!0 // false
!!'' // false
!!NaN // false

!!1 // true
!!'false' // true
!![] // true
!!{} // true
!!function(){} // true
!!/foo/ // true
```

# Number对象

## 静态属性

直接定义在`Number`对象上的属性为静态属性

`Number`的静态属性有：

- `Number.POSITIVE_INFINITY`：正的无限，指向`Infinity`。
- `Number.NEGATIVE_INFINITY`：负的无限，指向`-Infinity`。
- `Number.NaN`：表示非数值，指向`NaN`。
- `Number.MIN_VALUE`：表示最小的正数（即最接近0的正数，在64位浮点数体系中为`5e-324`），相应的，最接近0的负数为`-Number.MIN_VALUE`。
- `Number.MAX_SAFE_INTEGER`：表示能够精确表示的最大整数，即`9007199254740991`。
- `Number.MIN_SAFE_INTEGER`：表示能够精确表示的最小整数，即`-9007199254740991`。

```javascript
Number.POSITIVE_INFINITY // Infinity
Number.NEGATIVE_INFINITY // -Infinity
Number.NaN // NaN

Number.MAX_VALUE
// 1.7976931348623157e+308
Number.MAX_VALUE < Infinity
// true

Number.MIN_VALUE
// 5e-324
Number.MIN_VALUE > 0
// true

Number.MAX_SAFE_INTEGER // 9007199254740991
Number.MIN_SAFE_INTEGER // -9007199254740991
```

## 实例方法

### `Number.prototype.toString()`

用于将数值转为字符串形式

可以接收一个参数作为输出的进制，若省略参数则默认输出十进制

```javascript
(10).toString() // "10"
(10).toString(2) // "1010"
(10).toString(8) // "12"
(10).toString(16) // "a"
```

> 代码中数字需要放在括号中或者使用两个小数点，使用一个会报错
>
> ```javascript
> 10.toString(2)
> // SyntaxError: Unexpected token ILLEGAL
> 
> 10..toString(2)
> // "1010"
> 
> // 其他方法还包括
> 10 .toString(2) // "1010"
> 10.0.toString(2) // "1010"
> 
> //可以直接使用小数
> 10.5.toString() // "10.5"
> 10.5.toString(2) // "1010.1"
> 10.5.toString(8) // "12.4"
> 10.5.toString(16) // "a.8"
> ```

`toString()`方法只适用于十进制的数，若为其他的需要使用`parseInt`方法

### `Number.prototype.toFixed()`

先将一个数转为指定位数的小数，然后返回这个小数对应的字符串

```javascript
(10).toFixed(2) // "10.00"
10.005.toFixed(2) // "10.01"
```

> 有效范围为0~20

### `Number.prototype.toExponential()`

将一个数转为科学计数法形式

```javascript
(10).toExponential()  // "1e+1"
(10).toExponential(1) // "1.0e+1"
(10).toExponential(2) // "1.00e+1"

(1234).toExponential()  // "1.234e+3"
(1234).toExponential(1) // "1.2e+3"
(1234).toExponential(2) // "1.23e+3"
```

> 范围是0~20

### `Number.prototype.toPrecision()`

将一个数转为指定位数的有效数字

```javascript
(12.34).toPrecision(1) // "1e+1"
(12.34).toPrecision(2) // "12"
(12.34).toPrecision(3) // "12.3"
(12.34).toPrecision(4) // "12.34"
(12.34).toPrecision(5) // "12.340"
```

> 范围是1~21

### `Number.prototype.toLocaleString()`

接收一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式：

```javascript
(123).toLocaleString('zh-Hans-CN-u-nu-hanidec')
// "一二三"
```

可以接收第二个参数配置对象，用于定制指定用途的返回字符串

该对象的`style`属性指定输出样式，默认为`decimal`，表示输出十进制形式，若为`percent`则输出百分数

```javascript
(123).toLocaleString('zh-Hans-CN', { style: 'persent' })
// "12,300%"
```

若`style:'currency'`，则可以搭配`currency`属性，输出指定格式的货币字符串形式：

```javascript
(123).toLocaleString('zh-Hans-CN', { style: 'currency', currency: 'CNY' })
// "￥123.00"

(123).toLocaleString('de-DE', { style: 'currency', currency: 'EUR' })
// "123,00 €"

(123).toLocaleString('en-US', { style: 'currency', currency: 'USD' })
// "$123.00"
```

若省略了参数，则由浏览器自行决定如何处理，通常按照操作系统的地区设定

## 自定义方法

只能在`Number.prototype`对象上自定义方法，被`Number`的实例继承

# String对象

作为包装对象，用于生成字符串对象

```javascript
var s1 = 'abc';
var s2 = new String('abc');

typeof s1 // "string"
typeof s2 // "object"

s2.valueOf() // "abc"
```

字符串对象时一个类似数组的对象：

```javascript
new String('abc')
// String {0: "a", 1: "b", 2: "c", length: 3}

(new String('abc'))[1] // "b"
```

## 静态方法

### `String.fromCharCode()`

静态方法（定义在对象本身）

参数为一个或多个数值，代表Unicode码点，返回值是这些码点组成的字符串

```javascript
String.fromCharCode() // ""
String.fromCharCode(97) // "a"
String.fromCharCode(104, 101, 108, 108, 111)
// "hello"
```

> 传入参数不能大于`OxFFFF`即十进制的65535
>
> 传入参数大于，则会忽略多出的位数

## 实例属性

### `String.prototype.length`

返回字符串的长度

```javascript
'abc'.length // 3
```

## 实例方法

### `String.prototype.charAt()`

返回指定位置的字符，参数为从`0`开始编号的位置

```javascript
var s = new String('abc');

s.charAt(1) // "b"
s.charAt(s.length - 1) // "c"
```

若为整数，可以使用数组下标替代：

```javascript
'abc'.charAt(1) // "b"
'abc'[1] // "b"
```

若为负数或大于等于字符串的长度，会返回空字符串：

```javascript
'abc'.charAt(-1) // ""
'abc'.charAt(3) // ""
```

### `String.prototype.charCodeAt()`

返回字符串指定位置的Unicode码点（十进制表示）

相当于`String.fromCharCode()`的逆操作

```javascript
'abc'.charCodeAt(1) // 98
```

若没有参数则返回首字符的Unicode码点

若参数为负数，或大于等于字符串的长度，则返回`NaN`

> 返回的码点不会大于65536（OxFFFF）

### `String.prototype.concat()`

用于连接两个字符串，返回一个新字符串

> 不改变原字符串

```javascript
var s1 = 'abc';
var s2 = 'def';

s1.concat(s2) // "abcdef"
s1 // "abc"
```

若参数不是字符串，则会将其转化为字符串再进行连接

可以接收多个参数

### `String.prototype.slice()`

从原字符串取出子字符串并返回

+ 第一个参数为字符串开始的位置，第二个参数为结束位置（不含该位置）

+ 省略第二个参数则一直到原字符串结束

+ 若参数为负数，则从结尾开始倒数计算位置

+ 若第一个参数大于第二个参数，则返回一个空字符串

> 不改变原字符串

```javascript
'JavaScript'.slice(0, 4) // "Java"

'JavaScript'.slice(4) // "Script"
```

### `String.prototype.substring()`

从原字符串取出子字符串并返回   与`slice()`类似

+ 第一个参数为字符串开始的位置，第二个参数为结束位置（不含该位置）
+ 省略第二个参数则一直到原字符串结束

- 若参数为负数，则将负数转为0

- 若第一个参数大于第二个参数，则会自动更换两个参数的位置

> 不改变原字符串

```javascript
'JavaScript'.substring(10, 4) // "Script"
// 等同于
'JavaScript'.substring(4, 10) // "Script"

'JavaScript'.substring(-3) // "JavaScript"
'JavaScript'.substring(4, -3) // "Java"
```

==*==由于规则违反直觉，不推荐使用`substring()`，推荐使用`slice()`

### `String.prototype.substr()`

与`slice`和`substring`方法的作用相同

+ 第一个参数为字符串开始位置，第二个参数为子字符串的长度
+ 省略第二个参数则一直到原字符串结束
+ 若第一个参数为负数，则从结尾开始倒数计算位置
+ 若第二个参数为负数，则自动转为0，因而返回空字符串

> 不改变原字符串

```javascript
'JavaScript'.substr(4, 6) // "Script"

'JavaScript'.substr(-6) // "Script"
'JavaScript'.substr(4, -1) // ""
```

### `String.prototype.indexOf()`、`String.prototype.lastIndexOf()`

`indexOf()`用于确定一个字符串在另一个字符串中第一次出现的位置，返回匹配开始的位置

```javascript
'hello world'.indexOf('o') // 4
'JavaScript'.indexOf('script') // -1
```

接收第二个参数，表示从该位置向后匹配：

```javascript
'hello world'.indexOf('o', 6) // 7
```

`lastIndexOf()`为从后往前匹配，字符串第一次出现的位置（即从前往后最后一次出现的位置）

```javascript
'hello world'.lastIndexOf('o') // 7
'hello world'.lastIndexOf('o', 6) // 4
```

### `String.prototype.trim()`

用于去除字符串两段的空格、制表符（`\t`、`\v`）、换行符（`\n`）、回车符（`\r`），返回一个新字符串

> 不改变原字符串

```javascript
'  hello world  '.trim()
// "hello world".

'\r\nabc \t'.trim() // 'abc'
```

### `String.prototype.toLowerCase()`、`String.prototype.toUpperCase()`

用于将一个字符串全部转为小写/大写

> 不改变原字符串



### `String.prototype.match()`

用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串

若没有匹配项，则返回`null`

```javascript
'cat, bat, sat, fat'.match('at') // ["at"]
'cat, bat, sat, fat'.match('xt') // null
```

返回的数组有`index`属性和`input`属性，表示匹配字符串开始的位置和原始字符串

```javascript
var matches = 'cat, bat, sat, fat'.match('at');
matches.index // 1
matches.input // "cat, bat, sat, fat"
```

还可以使用正则表达式作为参数

### `String.prototype.search()`、`String.prototype.replace()`

`search()`用法基本等同于`match`，但是返回值为匹配的第一个位置

若没有匹配，则返回`-1`

```javascript
'cat, bat, sat, fat'.search('at') // 1
```

同样可以使用正则表达式作为参数

`replace()`用于替换匹配的子字符串，一般情况下只替换第一个匹配

（除非使用带有`g`修饰符的正则表达式）

```javascript
'aaa'.replace('a', 'b') // "baa"
```

同样可以使用正则表达式

### `String.prototype.split()`

按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组

+ 若分割规则为空字符串，则返回的数组成员为原字符串的每一个字符
+ 若省略参数，则返回数组的唯一成员为原字符串
+ 若满足分割规则的两个部分紧邻，则返回数组之中会有一个空字符串
+ 若满足分割规则的部分位于字符串开头或结尾，则返回数组的第一个或最后一个成员为空字符串
+ 接收第二个参数，用于限定返回数组的最大成员数

```javascript
'a|b|c'.split('|') // ["a", "b", "c"]

'a|b|c'.split('') // ["a", "|", "b", "|", "c"]

'a|b|c'.split() // ["a|b|c"]

'a||c'.split('|') // ['a', '', 'c']

'|b|c'.split('|') // ["", "b", "c"]
'a|b|'.split('|') // ["a", "b", ""]

'a|b|c'.split('|', 0) // []
'a|b|c'.split('|', 1) // ["a"]
'a|b|c'.split('|', 2) // ["a", "b"]
'a|b|c'.split('|', 3) // ["a", "b", "c"]
'a|b|c'.split('|', 4) // ["a", "b", "c"]
```

同样可以使用正则表达式

### `String.prototype.localeCompare()`

用于比较两个字符串，返回一个整数

+ 若整数小于0，则第一个字符串小于第二个字符串
+ 若等于0，则相等
+ 若大于0，则第一个字符串大于第二个字符串

考虑自然语言的顺序

大写英文字母小于小写字母

接收第二个参数，用于指定所使用的语言（默认英语），根据该语言规则进行比较

```javascript
'apple'.localeCompare('banana') // -1
'apple'.localeCompare('apple') // 0

'B' > 'a' // false

'ä'.localeCompare('z', 'de') // -1
'ä'.localeCompare('z', 'sv') // 1
```













# Date对象

用于表示日期与时间

获取系统当前时间：

```javascript
var now = new Date();
now; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
now.getFullYear(); // 2015, 年份
now.getMonth(); // 5, 月份，注意月份范围是0~11，5表示六月
now.getDate(); // 24, 表示24号
now.getDay(); // 3, 表示星期三
now.getHours(); // 19, 24小时制
now.getMinutes(); // 49, 分钟
now.getSeconds(); // 22, 秒
now.getMilliseconds(); // 875, 毫秒数
now.getTime(); // 1435146562875, 以number形式表示的时间戳
```

创建指定日期的`Date`对象：

```javascript
var d = new Date(2015, 5, 19, 20, 15, 30, 123);
d; // Fri Jun 19 2015 20:15:30 GMT+0800 (CST)
```

> 月份值从0开始，0~11

解析一个符合ISO 8601格式的字符串：但返回的是一个时间戳

```javascript
var d = Date.parse('2015-06-24T19:49:22.875+08:00');
d; // 1435146562875
var d = new Date(1435146562875);
d; // Wed Jun 24 2015 19:49:22 GMT+0800 (CST)
```

转换本地时间或调整后的UTC时间：

```javascript
var d = new Date(1435146562875);
d.toLocaleString(); // '2015/6/24 下午7:49:22'，本地时间（北京时区+8:00），显示的字符串与操作系统设定的格式有关
d.toUTCString(); // 'Wed, 24 Jun 2015 11:49:22 GMT'，UTC时间，与本地时间相差8小时
```

# RegExp正则

看[正则表达式]()

# JSON

JSON = JavaScript Object Notation

是一种数据交换格式

JSON中的数据类型：

- number：和JavaScript的`number`完全一致；
- boolean：就是JavaScript的`true`或`false`；
- string：就是JavaScript的`string`；
- null：就是JavaScript的`null`；
- array：就是JavaScript的`Array`表示方式——`[]`；
- object：就是JavaScript的`{ ... }`表示方式。

> JSON规定字符集必须是UTF-8，字符串必须使用双引号`“”`，Object的键也需要使用`“”`。

### 序列化

```javascript
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp']
};
var s = JSON.stringify(xiaoming);
// s = {"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]}
```

优化输出效果：

```javascript
JSON.stringify(xiaoming,null,' ');

s = {
    "name": "小明",
    "age": 14,
    "gender": true,
    "height": 1.65,
    "grade": null,
    "middle-school": "\"W3C\" Middle School",
    "skills": [
        "JavaScript",
        "Java",
        "Python",
        "Lisp"
    ]
}
```

第二项参数用于控制筛选对象键值的方法

若想输出指定的属性：

```javascript
JSON.stringify(xiaoming, ['name', 'skills'], '  ');

s = {
    "name": "小明",
    "skills": [
        "JavaScript",
        "Java",
        "Python",
        "Lisp"
    ]
}
```

或传入函数使对象的键值获得处理：

```javascript
function convert(key, value) {
    if (typeof value === 'string') {
        return value.toUpperCase();
    }
    return value;
}

JSON.stringify(xiaoming, convert, '  ');

s = {
    "name": "小明",
    "age": 14,
    "gender": true,
    "height": 1.65,
    "grade": null,
    "middle-school": "\"W3C\" MIDDLE SCHOOL",
    "skills": [
        "JAVASCRIPT",
        "JAVA",
        "PYTHON",
        "LISP"
    ]
}
```

精确化控制序列化的键值：

```javascript
var xiaoming = {
    name: '小明',
    age: 14,
    gender: true,
    height: 1.65,
    grade: null,
    'middle-school': '\"W3C\" Middle School',
    skills: ['JavaScript', 'Java', 'Python', 'Lisp'],
    toJSON: function () {
        return { // 只输出name和age，并且改变了key：
            'Name': this.name,
            'Age': this.age
        };
    }
};

JSON.stringify(xiaoming); // '{"Name":"小明","Age":14}'
```

### 反序列化

使用`JSON.parse()`将JSON格式的字符串对象转换成一个JavaScript对象：

```javascript
JSON.parse('[1,2,3,true]'); // [1, 2, 3, true]
JSON.parse('{"name":"小明","age":14}'); // Object {name: '小明', age: 14}
JSON.parse('true'); // true
JSON.parse('123.45'); // 123.45
```

还可接收一个函数，用于转换解析的属性：

```javascript
var obj = JSON.parse('{"name":"小明","age":14}', function (key, value) {
    if (key === 'name') {
        return value + '同学';
    }
    return value;
});
obj; // {name: '小明同学', age: 14}
```

