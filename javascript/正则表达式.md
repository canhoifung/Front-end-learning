# `RegExp`正则

用于匹配字符串。

匹配规则：

1. `\d`可以匹配一个数字，`\w`可以匹配一个字母或数字
   - `'00\d'`可以匹配`'007'`，但无法匹配`'00A'`；
   - `'\d\d\d'`可以匹配`'010'`；
   - `'\w\w'`可以匹配`'js'`；
2. `.`可以匹配任意字符，`\s`匹配一个空格（包括Tab等空白符）
   - `'js.'`可以匹配`'jsp'`、`'jss'`、`'js!'`等等
3. `*`表示任意个字符（包括0个），`+`表示至少一个字符，`?`表示0个或1个字符，`{n}`表示n个字符，`{n,m}`表示n至m个字符
   - `\d{3}\s+\d{3,8}`表示匹配3个数字，至少有一个空格，有3-8个数字。
   - `\d{3}\-\d{3,8}`可以匹配`010-12345`，`-`横杠为特殊字符，需要使用`\`转义

### 正则进阶

可以使用`[]`表示范围来进行更精确的匹配

- `[0-9a-zA-Z\_]`可以匹配一个数字、字母或者下划线；
- `[0-9a-zA-Z\_]+`可以匹配至少由一个数字、字母或者下划线组成的字符串，比如`'a100'`，`'0_Z'`，`'js2015'`等等；
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]*`可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；
- `[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}`更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。

`A|B`可以匹配A或B，所以`(J|j)ava(S|s)cript`可以匹配`'JavaScript'`、`'Javascript'`、`'javaScript'`或者`'javascript'`。

`^`表示行的开头，`^\d`表示必须以数字开头。

`$`表示行的结束，`\d$`表示必须以数字结束。

你可能注意到了，`js`也可以匹配`'jsp'`，但是加上`^js$`就变成了整行匹配，就只能匹配`'js'`了

### 正则使用

创建正则表达式方法：

1. 直接通过`/正则表达式/`表示
2. 通过`new RegExp('正则表达式')`创建一个RegExp对象

```javascript
var re1 = /ABC\-001/;
var re2 = new RegExp('ABC\\-001');

re1; // /ABC\-001/
re2; // /ABC\-001/
```

#### `test()`

用于测试给定的字符串是否符合条件

```javascript
var re = /^\d{3}\-\d{3,8}$/;
re.test('010-12345'); // true
re.test('010-1234x'); // false
re.test('010 12345'); // false
```

#### 切分字符串

用正则表达式切分字符串比用固定的字符更灵活，请看正常的切分代码：

```
'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
```

用正则表达式：

```
'a b   c'.split(/\s+/); // ['a', 'b', 'c']
```

无论多少个空格都可以正常分割。加入`,`：

```
'a,b, c  d'.split(/[\s\,]+/); // ['a', 'b', 'c', 'd']
```

再加入`;`：

```
'a,b;; c  d'.split(/[\s\,\;]+/); // ['a', 'b', 'c', 'd']
```

> `+`意为匹配前面一个表达式1次或多次，等价于`{1,}`

#### 分组

使用`()`表示要提取的分组，如：

```javascript
^(\d{3})-(\d{3,8})$
//分别定义了两个组
```

实例：

```javascript
var re = /^(\d{3})-(\d{3,8})$/;
re.exec('010-12345'); // ['010-12345', '010', '12345']
re.exec('010 12345'); // null
```

定义了组后，需要使用`exec()`方法提取子串，

1. 匹配成功返回一个`Array`，第一个元素是匹配到的整个字符，后面的是匹配成功的子串
2. 若失败会返回一个`null`

#### 贪婪匹配

正则匹配默认为贪婪匹配，即会匹配尽可能多的字符。

```javascript
var re = /^(\d+)(0*)$/;
re.exec('102300'); // ['102300', '102300', '']
```

由于`\d+`采用贪婪匹配，直接把后面的`0`全部匹配了，结果`0*`只能匹配空字符串了。

```javascript
var re = /^(\d+?)(0*)$/;
re.exec('102300'); // ['102300', '1023', '00']
```

> 添加`?`使`\d+`采用非贪婪匹配

#### 全局搜索

`g`，表示全局匹配：

```javascript
var r1 = /test/g;
// 等价于:
var r2 = new RegExp('test', 'g');
```

全局匹配可以多次执行`exec()`方法来搜索一个匹配的字符串。当我们指定`g`标志后，每次运行`exec()`，正则表达式本身会更新`lastIndex`属性，表示上次匹配到的最后索引：

```javascript
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;

// 使用全局匹配:
re.exec(s); // ['JavaScript']
re.lastIndex; // 10

re.exec(s); // ['VBScript']
re.lastIndex; // 20

re.exec(s); // ['JScript']
re.lastIndex; // 29

re.exec(s); // ['ECMAScript']
re.lastIndex; // 44

re.exec(s); // null，直到结束仍没有匹配到
```

全局匹配类似搜索，因此不能使用`/^...$/`，那样只会最多匹配一次。

正则表达式还可以指定`i`标志，表示忽略大小写，`m`标志，表示执行多行匹配。

