# 函数基础

## 1.函数调用

函数允许传入任意个参数不影响调用，可多可少可无

### 1.`arguments`关键字

只在函数内部起作用，切永远指向当前函数的调用者传入的所有参数，类似`Array`但不是。

如：

```javascript
function foo(x) {
    console.log('x = ' + x); // 10
    for (var i=0; i<arguments.length; i++) {
        console.log('arg ' + i + ' = ' + arguments[i]); // 10, 20, 30
    }
}
foo(10, 20, 30);
//若传入参数为空，则
arguments.length === 0;
```

> `arguments`常用于判断传入参数的个数

### 2.`rest`参数 ==ES6==

当函数已经规定了如`a`，`b`类的参数，而想获得除已规定参数外的参数时，可以将函数改写成：

```javascript
function foo(a, b, ...rest) {
    console.log('a = ' + a);
    console.log('b = ' + b);
    console.log(rest);
}

foo(1, 2, 3, 4, 5);
// 结果:
// a = 1
// b = 2
// Array [ 3, 4, 5 ]

//若传入的参数少于已规定的参数，rest参数会接收一个空数组而不是undefined
foo(1);
// 结果:
// a = 1
// b = undefined
// Array []
```

## 2.变量作用域

### 1.局部作用域

如果一个变量在函数体内部申明，则该变量的作用域为==整个函数体==，在函数体外不可引用该变量：

```javascript
'use strict';

function foo() {
    var x = 1;
    x = x + 1;
}

x = x + 2; // ReferenceError! 无法在函数体外引用变量x
```

> 两个不同的函数各自申明了同一个变量，变量只在各自的函数体内起作用

若函数嵌套，内部函数可以访问外部函数定义的变量，反之不行：

```javascript
'use strict';

function foo() {
    var x = 1;
    function bar() {
        var y = x + 1; // bar可以访问foo的变量x!
    }
    var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
}
```

> 若内外函数变量名**重名**，调用变量时，优先从==自身函数定义==开始，若自身函数定义了变量名，则会忽略外部函数的变量

### 2.变量提升

函数定义时，优先将所有申明的变量==’提升’==到函数顶部：

> 会提升==变量的声明==，但不会提升==变量的赋值==

> `fucntion`的声明先于变量的声明！==***==

```javascript
'use strict';

function foo() {
    var x = 'Hello, ' + y; 
    console.log(x); //Hello,undefined
    var y = 'Bob';
}

-----相当于
function foo(){
    var x,y;
    x = 'Hello, ' + y;
    console.log(x);
    y = 'Bob';
}

```

### 3.全局作用域

不在任何函数内定义的变量具有全局作用域。

```javascript
'use strict';

var course = 'Learn JavaScript';
alert(course); // 'Learn JavaScript'
alert(window.course); // 'Learn JavaScript'
```

> 具有全局作用域的变量实际为绑定到全局对象`window`的一个属性

### 4.名字空间

当使用不同的JavaScript空间时若使用了相同的全局变量或定义了相同名字的顶层函数，会造成命名冲突，解决方法时建立一个自己的全局变量，将所有变量和函数绑定到全局变量中：

```javascript
// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = 'myapp';
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return 'foo';
};
```

### 5.`var`、`let`、`const`

在`for`循环等语句块中无法定义具有局部作用域的变量

```javascript
'use strict';

function foo() {
    for (var i=0; i<100; i++) {
        //
    }
    return i; // 仍然可以引用变量i，返回100
}
```

因此使用`let`代替`var`申明一个具有块级作用域的变量：

```javascript
'use strict';

function foo() {
    var sum = 0;
    for (let i=0; i<100; i++) {
        sum += i;
    }
    return i; //undefined
}
```

使用`const`来申明常量：

```javascript
'use strict';

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
```

> `const`同样具有块级作用域

### 6.解构赋值 ==ES6==

用于对一组变量进行赋值：

```javascript
let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']];
x; // 'hello'
y; // 'JavaScript'
z; // 'ES6'
```

忽略某些元素：

```javascript
let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素
z; // 'ES6'
```

同时解构赋值可以用于从一个对象中取出若干属性：

```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school',
    address: {
        city: 'Beijing',
        street: 'No.1 Road',
        zipcode: '100001'
    }
};
var {name, address: {city, zip}} = person;
name; // '小明'
city; // 'Beijing'
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined
```
若要使用的变量名和属性名不一致，可以使用这种语法获取：
```javascript
var person = {
    name: '小明',
    age: 20,
    gender: 'male',
    passport: 'G-12345678',
    school: 'No.4 middle school'
};

// 把passport属性赋值给变量id:
let {name, passport:id} = person;
name; // '小明'
id; // 'G-12345678'
// 注意: passport不是变量，而是为了让变量id获得passport属性:
passport; // Uncaught ReferenceError: passport is not defined
```

> 若变量已经被声明了，当再次赋值时会报错：
>
> ```javascript
> // 声明变量:
> var x, y;
> // 解构赋值:
> {x, y} = { name: '小明', x: 100, y: 200};
> // 语法错误: Uncaught SyntaxError: Unexpected token =
> ```
>
> 解决方法是利用小括号括起来：
>
> ```javascript
> ({x, y} = { name: '小明', x: 100, y: 200});
> ```

#### 使用场景

1. 交换变量的值

   ```javascript
   var x=1, y=2;
   [x, y] = [y, x]
   ```

2. 快速获取当前页面的域名和路径

   ```javascript
   var {hostname:domain, pathname:path} = location;
   ```

## 3.方法

指在一个对象中绑定函数，该函数成为该对象的方法。

```javascript
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
```

### 1.`this`

`this`始终指向当前变量，但：

```javascript
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge   //此处不用写getAge()，不然会报错
};

xiaoming.age(); // 以对象的方法形式调用，返回29, 正常结果
getAge(); // 单独调用函数，此时this指向全局对象window，返回NaN

//若
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
```

> 在`use strict`模式下，`this`指向`undefined`：
>
> ```javascript
> 'use strict';
> 
> var xiaoming = {
>     name: '小明',
>     birth: 1990,
>     age: function () {
>         var y = new Date().getFullYear();
>         return y - this.birth;
>     }
> };
> 
> var fn = xiaoming.age;
> fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
> ```

当对象方法内嵌套函数：

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```

`this`只在`age`方法的函数内指向`xiaoming`，在函数内部定义的函数，`this`指向`undefined`，在非`use strict`模式下指向`window`

修改方法：利用`that`变量捕获指向对象的`this`：

```javascript
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 29
```

### 2.`apply()`

用于指定函数的`this`指向哪个对象，只接受两个参数，第一个参数为需要绑定的`this`变量，第二个参数是`Array`，表示函数本身的参数

上面例子的`apply`使用：

```javascript
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function(){
        return getAge()
    }
};

xiaoming.age(); // NaN
getAge.apply(xiaoming, []); // 25, this指向xiaoming, 参数为空
```

### 3.`call()`

与`apply()`的区别是：

1. `apply()`将参数打包成`Array`后传入
2. `call()`将参数按顺序传入

```javascript
//若想调用Math.max(3,4,5)
Math.max.apply(null, [3, 5, 4]); // 5
Math.max.call(null, 3, 5, 4); // 5
```

> 对普通函数调用时，将`this`绑定为`null`

