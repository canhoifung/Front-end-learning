1. 请求DNS服务器获取相应域名对应的IP

2. 通过IP地址找到IP对应的服务器，请求建立TCP连接

3. 浏览器发送HTTP Request包后，服务器接受到请求包，开始处理请求包

4. 服务器调用自身服务，然后HTTP Response包

   HTTP应答码整理：

   + `1XX`－信息类(Information),表示收到Web浏览器请求，正在进一步的处理中 
   + `2XX`－成功类（Successful）,表示用户请求被正确接收，理解和处理例如：200 OK 
   + `3XX` - 重定向类(Redirection),表示请求没有成功，客户必须采取进一步的动作。 
   + `4XX `- 客户端错误(Client Error)，表示客户端提交的请求有错误 例如：404 NOT Found，意味着请求中所引用的文档不存在。 
   + `5XX` - 服务器错误(Server Error)表示服务器不能完成对请求的处理：如 500 

5. 浏览器收到后开始渲染Response包，收到全部内容后断开与服务器的TCP连接



渲染过程：[参考链接](https://www.cnblogs.com/chenyoumei/p/9156849.html)

一、构建DOM树和CSSOM树

1. 构建DOM树
   1. 读取HTML文档
   2. 将字节转换成字符
   3. 确定标签
   4. 将标签转换成节点
   5. 以节点构建DOM树
2. 构建CSSOM树
   1. 读取CSS文档
   2. 将字节转换成字符
   3. 确定标签
   4. 将标签转换成节点
   5. 以节点构建CSSOM树
3. 加载JS
   + 将堵塞DOM树加载
     + 解决方法1：`defer`属性，先下载JS文件等HTML解析后才开始执行已经下载的脚本
       + 脚本在`DOMContentLoaded`事件触发前执行（即刚读取完`</html>`标签）
       + 脚本内部不能使用`document.write()`
       + 脚本同时有`defer`、`async`，则`defer`不起效
     + 解决方法2：`async`属性，解析HTML网页同时并行下载脚本，下载完成后暂停解析HTML开始执行脚本，执行完成后就像解析HTML网页
       + 无法保证脚本执行顺序
       + 脚本内部不能使用`document.write()`

二、构建渲染树

渲染树`Render Tree`由DOM树和CSSOM树合并而成，且无先后条件关系，浏览器边加载边解析边渲染

三、页面重绘`repaint`和重流`reflow`

1. 渲染树转换为网页布局称为布局流（`flow`）
   
1. 渲染树节点发生变化，但不影响节点的空间位置和大小，就会触发重绘（`repaint`）
   
2. 布局显示到页面称为绘制（`paint`）

   1. 渲染树节点发生改变，且节点几何属性改变，则会触发重流（`reflow`）
3. ==重流必定重绘，重绘不一定重流==
   

   

